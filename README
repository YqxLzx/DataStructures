设S为 one student 设T为one teacher
学习C语言的一些笔记和知识点:

T:C语言中类型和类型的区别主要在于长度:
S:那么什么是长度?
T:变量存在内存里,占用多少字节的内存就是长度,比如最小的char占用1字节(1Byte === 8位bit),那么1字节能保存最大数是多少呢?是2^8 = 0 ~ 255!
但实际上是保存不到256的,因为8位的0和1有一位需要表示正负数,即只能保存2^7 = 128,所以char a 的保存数字的范围是-127 ~ 127,如果我们不需要负
数,可以用无符号修饰符,在整型变量前面 + unsigned 例如char a unsigned = 0 ~ 255
S:那还有其他整形变量吗？
T:很多,例如最常用的int,long,long long,short,那这些类型都多大呢?其实没有固定答案！
S:没有固定答案是什么意思？
T:他们在不同平台长度不一样!
S:???
T:比如int在32位系统是2字节 64位系统是4字节.
S:老子记不住他在不同平台长度怎么办！！！
T:其实根本不需要记,可以通过sizeof语句计算出长度,例如sizeof(int)
S:那我知道这个长度结果了,有什么用呢？
T:我们平常写的代码,变量的存储空间是自动分配的,在栈(stack)里,你应该还知道另外一个地方吧,叫堆(heap),堆需要手动申请,申请多大需要告诉他,这个主
要是在你申请内存的时候用
T:总而言之,不必为这个长度大小而纠结,你需要记住的是这个规则:char固定1字节,short <= int <= long <= long long
T:补充一下,小类型回自动转为大类型的,比如 char a = 1 ; int b = a ; 这个过程中,a会被隐式转换为int类型 
S:如果是大类型赚小类型呢?
T:整型之间只能从小转大！不能反过来！但是可以强制转换:值前面 + (类型),比如: int a = 1 ; char b = (char)a  ; 
S:这不会报错吗？那我小类型分配的内存少 ,我一个大的超过了这个内存 咋办？
T:那就会把多余的部分切除
S:切除?
T:是的,和你期望的输出就会不同了,c语言是弱类型语言,他的信条是绝对信任程序员,所以允许你做很多很多不安全操作,比如内存溢出等等
T:那我们继续到下一个环节了
S:好的
T:语句！
T:语句分为几种,其中表达式就是可计算语句,比如 1 , 1 + 1 , int a = 1,能获取到固定值的就是表达式语句,另外只有表达式语句能作为参数传递给函数,
能赋值给变量。变量声明语句,比如int a = 1 。请注意Undefined behavior,就是语言标准没有规定的内容,编译器可自己实现的,你总不希望你的代码在你电
脑运行和别人电脑运行结果不一样吧！
S:ok
T:那我们来看这个 printf("%d\n",1),%开头的代表占位符,代表你希望后面的参数以何种方式输出,需要注意的是printf函数的第一个参数必须得是数组.
S:占位符有多少个呢？
T:用的时候去查就可以了
S:我不用占位符呢?
T:那计算机就并不知道1是个数字。
S:我可以有多个占位符吗？
T:当然,占位符和后面的参数必须一一对应。
T:int a = 50; printf("%c\n",a) ; 你觉得这个会输出什么呢?
S:emmmm,%c 表示以char去读取a,char是整形,在ASCALL表中找到50,输出2
T:yes you are right!
S:那我想表达 字符的 22 是5050 ?
T:对,也就是[50, 50, 0],需要注意的是字符串有个终止符,在这里0是终止符。
T:那你知道为什么要占位符了吧?
S:因为c语言很多地方,读取者不关心你的类型,它只知道你传入了一段内存,它读取内存里的值。你要告诉他以什么规则取理解这段内存
T:不错,另外我们一般用char类型保存字符,因为ASCII码刚好从0到127,char正好表示的下.
T:float a = 3.14 , 这里float是浮点数类型,%f就是以浮点数类规则去解析,tip:float转整型会被截取小数点哦。
S:ok,整形算学完了吗？
T:是的,开始学数组!先科普一下:
c语言里的数组在js里是arrayBuffer
c语言大部分类型都是标量类型,非标量类型有数组和结构体,
声明一下数组int a[100],这个声明语句包含了两个信息,一个是类型信息,一个是长度信息。意味着int类型的数组只能保存int类型的数据.
T:那为什么要设计成同一类型呢?
S:不知道...
T:c语言的数组是紧凑二进制,你可以把数组想象成一段连续的内存,其实数组的类型决定了数组的步长。
S:???
T:假设你的环境里int是4字节,int arr[100]; a[10] = 1 arr是多少字节呢,400！假设从0x000 到0x100就是数组的内存空间,10是
可以看步数,int是4字节可以看成步长,就是每步4字节,走了10步,也就是走到0x040的位置.然后把0x040到0x043的格子赋值成1了。
T:能理解吗？
S:嗯嗯！
T:你但凡遇到 []这个符号,只有两种情况,第一种情况表示声明数组,第二种情况就是位移,无论指针还是数组都可以用[]位移!
T:这个是对数组的初始化 int a[3] = [1,2,3] 如果不初始化里面都是什么东西呢？
S:empty
T:实际上是ub,是神秘数字,没人知道,因为数组也实用了内存.但是这段内存你原来存放的数据不会自动格式化。
S:什么是但是这段内存你原来存放的数据不会自动格式化？
T:首先 内存其实没有删除这个操作,内存永远存在,内存你可以想象成一个无限长的胶卷,每个格子里存一份数据,你不能剪他,你只能复写它。
内存还有锁定和释放的操作,比如 int a 这4字节内存被锁定了.别人申请就不会给这4字节内存,然后释放了后别人才能申请到这个位置的内存,
但内存里的数据是不会清除的,没初始化之前是未知的!int a 没人知道这个a里是什么。
S:嗯嗯！我想一下,为什么没初始化的内存也有值呢？
T:因为你电脑里有很多其他程序,他们会使用内存,使用的过程中就会产生数据,如果每次用完还要清0很浪费性能。所以就直接释放了。
T:所谓的内存占用过多,不是存储的数据过多,而是你锁住的内存太多了,被程序锁住的内存太多,新的程序不能申请到足够内存
S:哦哦
T:那如果数组不完全初始化会怎么样呢,比如长度是20,我初始化了前10个
S:后10个就未知呗
T:不,其实他会全部初始化,后10个是0
S:为什么char数组可以表示字符串?我偏偏用其他的。
T:因为c语言是弱类型,他解析的时候不会关心你的数组是啥类型,他的解析规则就是固定不长1字节,就报错了。
T:并且他并不知道你数组的长度,他解析规则是1字节1字节遍历,直到遇到\0结束,所以我们得\0结尾,例如 char a[] = {'a', 'b' ,'c', '\0'};
T:上次我们说道数组是一段连续的内存,也就是本身他是没有值的,那为什么没有值的变量还能把值传递给函数呢,比如这样:char a[] = "123" 
prinft("%s\n",a)
S:是传递的内存地址吗?
T:非也,其实这里有隐式转换！数组作为值传递的场景,会被转换成指针！
S:什么是指针？
T:我先卖个关子,我们先来学习结构体,前面说到了数组是紧凑类型,但是每个元素必须是同类型,这样很不方便我们做一些操作,我们希望定义一种结构,
能支持多类型,这个就是结构体:
struct {
        char * name;
        int age;
    } a = {"小明", 16};
S:嗯嗯！
T:那sizeof(a)是多少呢？
S:不知道。。。
T:你不知道指针多大是吧,那我告诉你指针固定8字节,所以这个结构体的大小是 8 + sizeof(int) = 12,结构体和数组一样,就是每个元素在连续内存里摆列,
有顺序,紧凑的。所以大小就是加起来
S:soga
T:结构体也可以单独声明结构,例如:
#include <stdio.h>
struct AA {
    char * name;
    int age;
};

int main(){
    struct AA a = {"小明", 16};
    printf("姓名:%s,年龄:%d\n", a.name, a.age);
}
注意AA不是一个变量也不是一个类型,是一个结构名
S:fine 结构体很简单嘛
T:下面我们来到指针
S:嗯好
T:int * p 
指针用星号声明,指针要有类型,在这里就是int指针,
指针是标量类型,就是和int那些类似,是有具体的值的。
int * p = 1
这个看上去没问题吧
S:对啊,保存一个1没问题啊
T:非也,会报错。我们需要强制转换下类型 
int * p = (int *)1;
S:这里为什么要转换呢???
T:因为整型类型不会隐式转换成指针类型
S:soga
T:但是可以看出指针是标量类型,可以赋值。而结构体和数组指代连续内存,
没有值,所以不能赋值,来一个题目
#include <stdio.h>
int main(){
    int * p;
    p = (int *)1;
    p++;
    printf("%lld\n", (long long)p);
}
你猜猜这个输出是多少呢？
S:猜不到。。。
T:前面讲了指针和普通变量一样是标量类型,可以赋值,但是它的运算规则不太一样
指针的四则运算和整型不一样,+1相当于加步长。在这里int指针的步长是4字节,所以
所以指针 + 1,实际值+ 4了.
T:我们来总结一下指针的特点:
1.和普通标量类型一样能保存某个值
2.指针的内存大小和内存的编号长度是一致的
3.指针的加减运算要乘步长
4.指针支持解引用运算
S:第2,4个没学啊
T:现在学。内存的编号有长度。指针的长度刚好和内存的编号长度一致,那我们是不是可
以用指针来保存一个内存编号（也就是地址）。你知道啥叫内存编号么？
S:...不知道。。。
T:举个例子,假如你电脑1gb内存,那差不多1073741824字节内存,想象成1073741824这么多个格子
每个格子都有一个编号从0到1048575,那c语言有取值运算符,可以获取一个变量的地址。
#include <stdio.h>
int main(){
    int a = 1;
    printf("%lld", (long long)&a);
}
S:输出了好长的数字
T:这个地址就是64位的 如果你系统是64位的。
T:然后通过取址运算符我们可以得到一个指针类型,比如int a 用取址,得到的就是一个int类型指针,int *
#include <stdio.h>
int main(){
    int a = 1;
    int * p = &a;
    printf("%p", p);
}
代表着把a的内存地址编号赋值给了p,用来存储地址编号只是一种常见情况而已,如果有人说指针就是地址那是错的
比如他还可以表达空指针,可以表达句斌,当然也可以表达地址,因为指针的长度和地址一样,并且有方便的运算符,所以用来表达地址比较方便
S:嗯嗯（有点难了)
T:指针前面加*可以解引用,
#include <stdio.h>
int main(){
    int a = 1;
    int * p = &a;
    printf("%d\n", *p);
    p++;
    printf("%d\n", *p);
}
请记住,如果*出现在等号右边变量左边就是解引用,它的作用是把指针当地址解析,获取地址里存储的值
S:指针又不是连续内存 为什么要用步长来算？
T:指针只是标量类型,保存什么都可以,可以保存内存地址,但是内存本身都是连续的呀,计算机里的内存都是连续有编号的
我们可以通过加减操作位移指针,来表示不同的内存地址
T:补充一下,你知道什么叫累成溢出没
S:不知道。。。1g的内存 我申请了1.5g的大小？
T:就是操作不安全的内存,比如这个变量的内存区间是0x001到0x004,你去操作0x005,这种行为在强类型语言里会阻止,
弱类型语言里会妥协。
T:还记得数组可以隐式转换成指针吗？
#include <stdio.h>
int main(){
    int arr[3] = {1, 2, 3};
    int * p = arr;
    printf("%d\n", *p);
}
S:输出为什么是1啊
T:隐式转换规则是取数组第一个元素的首地址
T:再说一个概念野指针:我操作的是哪块地址我也不知道.